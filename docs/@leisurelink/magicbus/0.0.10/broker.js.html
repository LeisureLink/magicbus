<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: broker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: broker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var assert = require('assert-plus');
var Promise = require('bluebird');
var amqpUri = require('amqp-uri');

module.exports = Broker;

/**
 * Handles connection and channel communication with RabbitMQ
 *
 * @public
 * @constructor
 * @param {String} serviceDomainName - your service's domain name, i.e. "units"
 * @param {String} appName - your service's app name, i.e. "integration-hub"
 * @param {Object} connectionInfo - connection info to be passed to amqp-uri
 * @param {String} connectionInfo.host - host name
 * @param {String} connectionInfo.vhost - vhost (default /)
 * @param {String} connectionInfo.user - user name (default guest)
 * @param {String} connectionInfo.pass - password (default guest)
 */
function Broker(serviceDomainName, appName, connectionInfo) {
  assert.string(serviceDomainName, 'serviceDomainName');
  assert.string(appName, 'appName');
  assert.object(connectionInfo, 'connectionInfo');

  //Hold a reference on the instance so it can be replaced by a mock in tests
  this._amqp = require('amqplib');

  this._serviceDomainName = serviceDomainName;
  this._appName = appName;
  this._connectionInfo = connectionInfo;

  this._connection = null;
  this._routes = {};
}

Object.defineProperties(Broker.prototype, {
  /**
   * Registers a new route with a name and a pattern
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} name - the name of the route
   * @param {Object} pattern - the RoutePattern that defines the route's pattern
   */
  registerRoute: {
    value: function(name, pattern) {
      this._routes[name] = {
        pattern: pattern
      };
    },
    enumerable: true
  },

  /**
   * Get the route pattern for the given route name
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @returns {Object} the RoutePattern for the given route name
   */
  getRoutePattern: {
    value: function(routeName) {
      return this._routes[routeName].pattern;
    },
    enumerable: true
  },

  /**
   * Publish a message using the given parameters
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @param {String} routingKey - the message's routing key
   * @param {String} content - messageContent
   * @param {String} options - publishing options - passed to amqplib
   * @returns {Promise} a promise representing the result of the publish call
   */
  publish: {
    value: function(routeName, routingKey, content, options) {
      var self = this;

      return self._assertRoute(routeName).then(function(route) {
        var exchangeName = route.exchangeName;

        var published = route.channel.publish(exchangeName, routingKey, content, options);

        if (published) {
          return Promise.resolve();
        } else {
          return Promise.reject(new Error('Could not publish because the channel\'s write buffer was full.'));
        }
      });
    },
    enumerable: true
  },


  /**
   * Start consuming messages on the given route
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @param {Function} callback - function to be called with each message consumed
   * @param {String} options - consuming options - passed to amqplib
   * @returns {Promise} a promise representing the result of the consume call
   */
  consume: {
    value: function(routeName, callback, options) {
      var self = this;

      return self._assertRoute(routeName).then(function(route) {
        var queueName = route.queueName;

        return route.channel.consume(queueName, callback, options).then(/* strip result from promise */);
      });
    },
    enumerable: true
  },

  /**
   * Acknowledge that a message has been consumed
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @param {Object} message - the message to ack
   * @returns {Promise} a promise representing the result of the ack call
   */
  ack: {
    value: function(routeName, message) {
      var self = this;

      return self._assertRoute(routeName).then(function(route) {
        route.channel.ack(message);
      });
    },
    enumerable: true
  },

  /**
   * Notify RabbitMQ that a message was not successfully processed
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @param {Object} message - the message to nack
   * @param {Bool} allUpTo - if true, nacks all unacknowledged messages up to this one
   * @param {Bool} requeue - if true, requeue the message for consumption
   * @returns {Promise} a promise representing the result of the ack call
   */
  nack: {
    value: function(routeName, message, allUpTo, requeue) {
      var self = this;

      return self._assertRoute(routeName).then(function(route) {
        route.channel.nack(message, allUpTo, requeue);
      });
    },
    enumerable: true
  },


  /**
   * Close the connection and all associated channels
   *
   * @public
   * @method
   * @memberOf Broker.prototype
   */
  shutdown: {
    value: function() {
      if (this._connection) {
        this._connection.close();
      }
    },
    enumerable: true
  },

  /**
   * Create a new connection with the broker's configuration
   *
   * @private
   * @method
   * @memberOf Broker.prototype
   * @returns {Promise} a promise that is fulfilled with the resulting connection
   */
  _createConnection: {
    value: function() {
      var self = this;

      if (self._connection) {
        return Promise.resolve(self._connection);
      } else {
        var connectionString = amqpUri(self._connectionInfo);
        return self._amqp.connect(connectionString).then(function(conn) {
          self._connection = conn;
          return conn;
        });
      }
    },
    enumerable: false
  },


  /**
   * Assert that a route is configured in RabbitMQ
   *
   * @private
   * @method
   * @memberOf Broker.prototype
   * @param {String} routeName - the name of the route
   * @returns {Promise} a promise that is fulfilled with the resulting route (result has exchangeName or queueName, and channel properties)
   */
  _assertRoute: {
    value: function(routeName) {
      var self = this;

      var route = self._routes[routeName];
      var newChannel;

      if (route.channel) {
        return Promise.resolve(route);
      } else {
        return self._createConnection().then(function(conn) {
          return conn.createChannel();
        }).then(function(channel) {
          newChannel = channel;
          return route.pattern.assertRoute(self._serviceDomainName, self._appName, routeName, channel);
        }).then(function(topologyNames) {
          route.exchangeName = topologyNames.exchangeName;
          route.queueName = topologyNames.queueName;
          route.channel = newChannel;

          return route;
        });
      }
    },
    enumerable: false
  }

});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-MagicBus.html">MagicBus</a></li></ul><h3>Classes</h3><ul><li><a href="AbstractEnvelope.html">AbstractEnvelope</a></li><li><a href="BasicEnvelope.html">BasicEnvelope</a></li><li><a href="Broker.html">Broker</a></li><li><a href="Consumer.html">Consumer</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="Publisher.html">Publisher</a></li><li><a href="Subscriber.html">Subscriber</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Tue Oct 27 2015 14:12:21 GMT-0600 (MDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
